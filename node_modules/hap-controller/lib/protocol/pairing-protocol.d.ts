/**
 * Build and parse packets for pairing protocol requests.
 */
/// <reference types="node" />
import { TLV } from '../model/tlv';
declare const PairMethods: {
    PairSetup: number;
    PairSetupWithAuth: number;
};
/**
 * See Table 5-5
 */
export declare const ErrorCodes: {
    kTLVError_Unknown: number;
    kTLVError_Authentication: number;
    kTLVError_Backoff: number;
    kTLVError_MaxPeers: number;
    kTLVError_MaxTries: number;
    kTLVError_Unavailable: number;
    kTLVError_Busy: number;
};
/**
 * See Table 5-6, Table 7-38
 */
export declare const Types: {
    kTLVType_Method: number;
    kTLVType_Identifier: number;
    kTLVType_Salt: number;
    kTLVType_PublicKey: number;
    kTLVType_Proof: number;
    kTLVType_EncryptedData: number;
    kTLVType_State: number;
    kTLVType_Error: number;
    kTLVType_RetryDelay: number;
    kTLVType_Certificate: number;
    kTLVType_Signature: number;
    kTLVType_Permissions: number;
    kTLVType_FragmentData: number;
    kTLVType_FragmentLast: number;
    kTLVType_SessionID: number;
    kTLVType_Flags: number;
    kTLVType_Separator: number;
};
/**
 * See Table 5-7
 */
declare const PairingTypeFlags: {
    kPairingFlag_Transient: number;
    kPairingFlag_Split: number;
};
export { PairMethods, PairingTypeFlags };
export interface SessionKeys {
    AccessoryToControllerKey: Buffer;
    ControllerToAccessoryKey: Buffer;
}
export interface PairingData {
    AccessoryPairingID: string;
    AccessoryLTPK: string;
    iOSDevicePairingID: string;
    iOSDeviceLTSK: string;
    iOSDeviceLTPK: string;
}
export default class PairingProtocol {
    private AccessoryPairingID;
    private AccessoryLTPK;
    private iOSDevicePairingID;
    private iOSDeviceLTSK;
    private iOSDeviceLTPK;
    private pairSetup;
    private pairVerify;
    private sessionKeys;
    private srpClient;
    /**
     * Create the PairingProtocol object.
     *
     * @param {Object?} pairingData - Optional saved pairing data
     */
    constructor(pairingData?: PairingData);
    /**
     * Parse a buffer from a hex string.
     */
    static bufferFromHex(buf: string): Buffer;
    /**
     * Convert a buffer to a hex string.
     */
    static bufferToHex(buf: Buffer): string;
    /**
     * Determine whether or not we can use pair resume.
     *
     * @returns {boolean} Boolean indicating if pair resume is possible.
     */
    canResume(): boolean;
    /**
     * Return info if the current pairSetup process is Transient only
     *
     * @returns {boolean} Boolean indicating if the pairSetup process has only the transient flag set
     */
    isTransientOnlyPairSetup(): boolean;
    /**
     * Verify the provided PIN
     *
     * @param pin {string} PIN
     */
    verifyPin(pin: string): void;
    /**
     * Build step 1 of the pair setup process.
     *
     * @param {PairMethods} [pairMethod] - Method to use for pairing, default is PairSetupWithAuth
     * @param {PairingTypeFlags} [pairFlags] - Flags to use for Pairing for PairSetup
     * @returns {Promise} Promise which resolves to a Buffer.
     */
    buildPairSetupM1(pairMethod?: number, pairFlags?: number): Promise<Buffer>;
    /**
     * Parse step 2 of the pair setup process.
     *
     * @param {Buffer} m2Buffer - Buffer containing M2 response
     * @returns {Promise} Promise which resolves to a TLV object.
     */
    parsePairSetupM2(m2Buffer: Buffer): Promise<TLV>;
    /**
     * Build step 3 of the pair setup process.
     *
     * @param {Object} m2Tlv - TLV object containing M2 response
     * @param {string} pin - Setup PIN
     * @returns {Promise} Promise which resolves to a Buffer.
     */
    buildPairSetupM3(m2Tlv: TLV, pin: string): Promise<Buffer>;
    /**
     * Parse step 4 of the pair setup process.
     *
     * @param {Buffer} m4Buffer - Buffer containing M4 response
     * @returns {Promise} Promise which resolves to a TLV object.
     */
    parsePairSetupM4(m4Buffer: Buffer): Promise<TLV>;
    /**
     * Build step 5 of the pair setup process.
     *
     * @returns {Promise} Promise which resolves to a Buffer.
     */
    buildPairSetupM5(): Promise<Buffer>;
    /**
     * Parse step 6 of the pair setup process.
     *
     * @param {Buffer} m6Buffer - Buffer containing M4 response
     * @returns {Promise} Promise which resolves to a TLV object.
     */
    parsePairSetupM6(m6Buffer: Buffer): Promise<TLV>;
    /**
     * Build step 1 of the pair verify process.
     *
     * @returns {Promise} Promise which resolves to a Buffer.
     */
    buildPairVerifyM1(): Promise<Buffer>;
    /**
     * Parse step 2 of the pair verify process.
     *
     * @param {Buffer} m2Buffer - Buffer containing M2 response
     * @returns {Promise} Promise which resolves to a TLV object.
     */
    parsePairVerifyM2(m2Buffer: Buffer): Promise<TLV>;
    /**
     * Build step 3 of the pair verify process.
     *
     * @returns {Promise} Promise which resolves to a Buffer.
     */
    buildPairVerifyM3(): Promise<Buffer>;
    /**
     * Parse step 4 of the pair verify process.
     *
     * @param {Buffer} m4Buffer - Buffer containing M4 response
     * @returns {Promise} Promise which resolves to a TLV object.
     */
    parsePairVerifyM4(m4Buffer: Buffer): Promise<TLV>;
    /**
     * Get the session keys generated by the PairVerify process.
     *
     * @returns {Object}
     *   {
     *     AccessoryToControllerKey: {Buffer},
     *     ControllerToAccessoryKey: {Buffer},
     *   }
     */
    getSessionKeys(): SessionKeys;
    /**
     * Build step 1 of the add pairing process.
     *
     * @param {string} identifier - Identifier of the new controller
     * @param {Buffer} ltpk - Long-term public key of the new controller
     * @param {boolean} isAdmin - Whether or not the new controller is an admin
     * @returns {Promise} Promise which resolves to a Buffer.
     */
    buildAddPairingM1(identifier: string, ltpk: Buffer, isAdmin: boolean): Promise<Buffer>;
    /**
     * Parse step 2 of the add pairing process.
     *
     * @param {Buffer} m2Buffer - Buffer containing M2 response
     * @returns {Promise} Promise which resolves to a TLV object.
     */
    parseAddPairingM2(m2Buffer: Buffer): Promise<TLV>;
    /**
     * Build step 1 of the remove pairing process.
     *
     * @param {Buffer} identifier - Identifier of the controller to remove
     * @returns {Promise} Promise which resolves to a Buffer.
     */
    buildRemovePairingM1(identifier: Buffer): Promise<Buffer>;
    /**
     * Parse step 2 of the remove pairing process.
     *
     * @param {Buffer} m2Buffer - Buffer containing M2 response
     * @returns {Promise} Promise which resolves to a TLV object.
     */
    parseRemovePairingM2(m2Buffer: Buffer): Promise<TLV>;
    /**
     * Build step 1 of the list pairings process.
     *
     * @returns {Promise} Promise which resolves to a Buffer.
     */
    buildListPairingsM1(): Promise<Buffer>;
    /**
     * Parse step 2 of the list pairings process.
     *
     * @param {Buffer} m2Buffer - Buffer containing M2 response
     * @returns {Promise} Promise which resolves to a TLV object.
     */
    parseListPairingsM2(m2Buffer: Buffer): Promise<TLV>;
    /**
     * Build step 1 of the pair resume process.
     *
     * @returns {Promise} Promise which resolves to a Buffer.
     */
    buildPairResumeM1(): Promise<Buffer>;
    /**
     * Parse step 2 of the pair resume process.
     *
     * @param {Buffer} m2Buffer - Buffer containing M2 response
     * @returns {Promise} Promise which resolves to a TLV object.
     */
    parsePairResumeM2(m2Buffer: Buffer): Promise<TLV>;
    /**
     * Get the data (keys) that needs to be stored long-term.
     *
     * @returns {PairingProtocol} Object containing the keys that should be stored.
     */
    getLongTermData(): PairingData | null;
}
//# sourceMappingURL=pairing-protocol.d.ts.map