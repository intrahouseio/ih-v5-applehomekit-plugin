/**
 * Class to represent a multi-request HTTP connection.
 */
/// <reference types="node" />
import { EventEmitter } from 'events';
import { SessionKeys } from '../../protocol/pairing-protocol';
export interface HttpResponse {
    statusCode: number;
    headers: Record<string, string>;
    body: Buffer;
}
export default class HttpConnection extends EventEmitter {
    private address;
    private port;
    private state;
    private socket;
    private sessionKeys;
    private a2cCounter;
    private c2aCounter;
    /**
     * Initialize the HttpConnection object.
     *
     * @param {string} address - IP address of the device
     * @param {number} port - HTTP port
     */
    constructor(address: string, port: number);
    /**
     * Set the session keys for the connection.
     *
     * @param {Object} keys - The session key object obtained from PairingProtocol
     */
    setSessionKeys(keys: SessionKeys): void;
    /**
     * Open a socket if necessary.
     *
     * @returns {Promise} Promise which resolves when the socket is open and
     *                    ready.
     */
    private _open;
    /**
     * Send a GET request.
     *
     * @param {string} path - Path to request
     * @returns {Promise} Promise which resolves to a buffer containing the
     *                    response body.
     */
    get(path: string): Promise<HttpResponse>;
    /**
     * Send a POST request.
     *
     * @param {string} path - Path to request
     * @param {Buffer|string} body - Request body
     * @param {string?} contentType - Request content type
     * @returns {Promise} Promise which resolves to a buffer containing the
     *                    response body.
     */
    post(path: string, body: Buffer | string, contentType?: string): Promise<HttpResponse>;
    /**
     * Send a PUT request.
     *
     * @param {string} path - Path to request
     * @param {Buffer|string} body - Request body
     * @param {string?} contentType - Request content type
     * @param {boolean?} readEvents - Whether or not to read EVENT messages after
     *                   initial request
     * @returns {Promise} Promise which resolves to a buffer containing the
     *                    response body.
     */
    put(path: string, body: Buffer | string, contentType?: string, readEvents?: boolean): Promise<HttpResponse>;
    /**
     * Send a request.
     *
     * @param {Buffer} body - Request body
     * @param {boolean?} readEvents - Whether or not to read EVENT messages after
     *                   initial request
     * @returns {Promise} Promise which resolves to a buffer containing the
     *                    response body.
     */
    request(body: Buffer, readEvents?: boolean): Promise<HttpResponse>;
    /**
     * Encrypt request data.
     *
     * @param {Buffer} data - Data to encrypt
     * @returns {Buffer} Encrypted data.
     */
    private _encryptData;
    /**
     * Create an HTTP response parser.
     *
     * @param {(response: HttpResponse) => void} resolve - Function to call with response
     * @returns {Object} HTTPParser object.
     */
    private _buildHttpResponseParser;
    /**
     * Send an encrypted request.
     *
     * @param {Buffer} data - Request body
     * @param {boolean?} readEvents - Whether or not to read EVENT messages after
     *                   initial request
     * @returns {Promise} Promise which resolves to a buffer containing the
     *                    response body.
     */
    private _requestEncrypted;
    /**
     * Send a clear-text request.
     *
     * @param {Buffer} data - Request body
     * @param {boolean?} readEvents - Whether or not to read EVENT messages after
     *                   initial request
     * @returns {Promise} Promise which resolves to a buffer containing the
     *                    response body.
     */
    private _requestClear;
    /**
     * Close the socket.
     */
    close(): void;
}
//# sourceMappingURL=http-connection.d.ts.map